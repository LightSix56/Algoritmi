## Жадный алгоритм для составления расписания(вариант 2)

## Определение алгоритма

**Жадный алгоритм для составления расписания** — это алгоритм, который последовательно распределяет задачи по машинам, на каждой итерации выбирая машину с наименьшей текущей загрузкой, чтобы минимизировать общее время завершения всех задач (makespan).

## Анализ работы алгоритма

Алгоритм работает следующим образом:

1. Инициализируется список `machine_loads`, представляющий текущую загрузку каждой из `num_machines` машин. Все значения изначально равны 0.
2. Инициализируется список `assignment`, который будет хранить номер машины, которой назначена каждая задача из списка `jobs`.
3. Цикл `for i in range(len(jobs))` перебирает каждую задачу по порядку.
4. На каждой итерации:
   - Вычисляется `min_load = min(machine_loads)` — находит минимальную текущую загрузку среди всех машин.
   - `min_machine = machine_loads.index(min_load)` находит индекс первой машины (с конца списка, если есть совпадения) с этой минимальной загрузкой.
   - `machine_loads[min_machine] += jobs[i]` — добавляет длительность текущей задачи `jobs[i]` к загрузке выбранной машины.
   - `assignment[i] = min_machine` — записывает номер выбранной машины как назначенную для текущей задачи `i`.
5. После распределения всех задач, `makespan = max(machine_loads)` вычисляет максимальное время завершения, то есть наибольшую загрузку среди всех машин.

## Временная сложность

O(m * n), где m — количество машин, n — количество задач.

## Обоснование временной сложности

- Цикл `for i in range(len(jobs))` выполняется `n` раз.
- Внутри цикла выполняется `min(machine_loads)`, что требует O(m) операций для поиска минимального значения в списке длиной `m`.
- Также внутри цикла `machine_loads.index(min_load)` может потребовать до O(m) времени в худшем случае, если минимальное значение находится в конце списка.
- Остальные операции внутри цикла (например, `machine_loads[min_machine] += jobs[i]`) выполняются за O(1).
- Таким образом, внутренняя часть цикла занимает O(m) времени.
- Общая временная сложность составляет O(n * m).
- Вычисление `max(machine_loads)` после цикла занимает O(m), что не доминирует над O(n * m).
- Следовательно, асимптотическая сложность алгоритма — O(n * m).

---

## Контрольный вопрос(вариант 2)

**Коэффициент аппроксимации**

Для задачи минимизации коэффициент аппроксимации α (α ≥ 1) определяется как отношение стоимости решения, найденного приближённым алгоритмом, к стоимости оптимального решения:

**α = A(I) / OPT(I)**

где:
- `A(I)` — стоимость решения, выданного алгоритмом на входе `I`,
- `OPT(I)` — стоимость оптимального решения для входа `I`.

**Что он характеризует:**
Коэффициент α показывает, **насколько хуже** (в худшем случае) решение, полученное приближённым алгоритмом, по сравнению с оптимальным. Чем ближе α к 1, тем лучше алгоритм. Например, α=2 означает, что алгоритм всегда даёт решение, не хуже чем в 2 раза от оптимального.
