# Жадный алгоритм для составления расписания

## Определение алгоритма

**Жадный алгоритм для составления расписания** — это алгоритм, который на каждом шаге назначает очередную работу на машину с минимальным текущим временем выполнения, стремясь к равномерному распределению нагрузки и минимизации максимального времени завершения всех работ (makespan).

## Подробный анализ работы алгоритма

Алгоритм работает по принципу "жадного выбора", на каждом шаге принимая локально оптимальное решение в надежде достичь глобального приближения к оптимальному решению.

1. **Инициализация:**
   - `machines = [0] * num_machines`: Создается список, где `machines[i]` хранит общее время работы, назначенное на машину `i`. Изначально все машины свободны (время = 0).
   - `schedule = [[] for _ in range(num_machines)]`: Создается список списков для отслеживания конкретных работ, назначенных на каждую машину.

2. **Цикл по работам:**
   - `for duration in job_durations:`: Алгоритм перебирает каждую работу по очереди, заданную своей длительностью.
   - `min_machine_idx = 0`: Инициализируется индекс машины, на которую будет назначена текущая работа. Предполагается, что это первая машина.
   - `for i in range(1, num_machines):`: Внутренний цикл ищет машину с минимальным временем выполнения на данный момент.
     - `if machines[i] < machines[min_machine_idx]:`: Сравнивает время выполнения на текущей машине `i` с временем на предполагаемой "минимальной" машине. Если текущая машина "свободнее", обновляется `min_machine_idx`.
   - `machines[min_machine_idx] += duration`: Длительность текущей работы добавляется к общему времени выполнения на выбранной машине, эффективно "назначая" работу.
   - `schedule[min_machine_idx].append(duration)`: Длительность работы добавляется в список работ, назначенных на эту машину, для отслеживания.

3. **Возврат результата:**
   - Функция возвращает два списка: `machines` (финальные времена завершения для каждой машины) и `schedule` (расписание работ по машинам).

## Временная сложность по Big O

O(m * n), где `m` — количество машин, `n` — количество работ.

## Обоснование временной сложности

- **Внешний цикл:** `for duration in job_durations:` — выполняется `n` раз, по количеству работ.
- **Внутренний цикл:** `for i in range(1, num_machines):` — внутри внешнего цикла выполняется `m - 1` раз, по количеству машин (минус одна, с которой начинается сравнение).
- Внутри внутреннего цикла выполняются элементарные операции (сравнение, присваивание), которые считаются за O(1).
- Таким образом, общее количество операций пропорционально `n * (m - 1)`, что в нотации Big O упрощается до **O(n * m)** или **O(m * n)**.
