# Рекурсивная функция нахождения НОД по алгоритму Евклида

## 1. Описание функции

Функция нахождения наибольшего общего делителя (НОД) возвращает наибольшее натуральное число, на которое делятся два заданных целых числа без остатка.  
В данной работе функция реализована рекурсивно с использованием **алгоритма Евклида**, основанного на следующем свойстве:  
> НОД(a, b) = НОД(b, a mod b), при условии, что b ≠ 0.  
> Если b = 0, то НОД(a, 0) = |a|.

Этот подход позволяет эффективно вычислять НОД без полного перебора делителей.

## 2. Описание работы программы

Программа использует рекурсивную функцию с двумя аргументами: `a` и `b`.  
- **Базовый случай**: если второй аргумент `b` равен нулю, функция возвращает значение первого аргумента `a`.  
- **Рекурсивный шаг**: в противном случае функция вызывает саму себя с аргументами `b` и `a % b` (остаток от деления `a` на `b`).

Например, при вызове функции с аргументами `a = 48` и `b = 18` последовательность рекурсивных вызовов будет следующей:
- `gcd(48, 18)` → `gcd(18, 12)`  
- `gcd(18, 12)` → `gcd(12, 6)`  
- `gcd(12, 6)` → `gcd(6, 0)` → возврат `6`

Таким образом, результат вычисления — **6**, что совпадает с математически верным значением НОД(48, 18).

## 3. Временная сложность (Big O)

Временная сложность рекурсивного алгоритма Евклида составляет:  
**O(log₂(min(a, b)))**

## 4. Обоснование сложности

На каждом шаге алгоритма значение второго аргумента заменяется остатком от деления, который строго меньше предыдущего значения. В худшем случае (при последовательности чисел Фибоначчи) количество шагов пропорционально логарифму от меньшего из двух входных чисел.  
Поскольку остаток уменьшается по крайней мере вдвое каждые два шага, общее число рекурсивных вызовов ограничено сверху константой, умноженной на `log₂(min(a, b))`.  
Следовательно, временная сложность алгоритма — **O(log₂(min(a, b)))**.

## 5. Результаты работы кодов на всех языках

Реализации функции были выполнены на трёх языках программирования: Python, Java и C++.  
Во всех случаях функция вызывалась с одинаковыми входными параметрами: `a = 48`, `b = 18`.

Ожидаемый результат: **6**.

Фактические результаты выполнения программ:
- **Python**: вывел `6`
- **Java**: вывел `6`
- **C++**: вывел `6`

Все три реализации корректно вычислили НОД и выдали идентичный результат, что подтверждает правильность как алгоритма, так и его реализации на разных языках.

## **6. Контрольный вопрос 8**
  
Количество перестановок множества из n элементов равно n!
