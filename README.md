1. Сортировка выбором (Selection Sort)
 * Принцип работы: Алгоритм последовательно проходит по массиву. На каждом шаге он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.
 * Временная сложность: O(n^2) во всех случаях (худшем, среднем и лучшем).
2. Сортировка обменом (пузырьком) (Bubble Sort)
 * Принцип работы: Алгоритм многократно проходит по списку, сравнивая попарно соседние элементы. Если элементы стоят в неверном порядке, они меняются местами. В результате каждого прохода наибольший элемент "всплывает" в конец массива.
 * Временная сложность: O(n^2).
3. Сортировка вставками (Insertion Sort)
 * Принцип работы: Массив мысленно делится на отсортированную и неотсортированную части. Алгоритм поочередно берет элементы из неотсортированной части и вставляет их на нужную позицию в уже отсортированную часть.
 * Временная сложность: O(n^2).
4. Сортировка слиянием (Merge Sort)
 * Принцип работы: Алгоритм основан на принципе "разделяй и властвуй". Массив рекурсивно делится пополам до тех пор, пока не останутся подмассивы из одного элемента. Затем эти отсортированные подмассивы сливаются обратно в один отсортированный массив.
 * Временная сложность: O(n \log n) во всех случаях.
5. Сортировка Шелла (Shell Sort)
 * Принцип работы: Это усовершенствованная версия сортировки вставками. Алгоритм сравнивает и сортирует элементы, которые находятся на определенном расстоянии (шаге) друг от друга. Шаг постепенно уменьшается, что позволяет элементам быстрее перемещаться на свои позиции.
 * Временная сложность: Зависит от выбранной последовательности шагов, в среднем около O(n \log n) или O(n^{3/2}).
6. Быстрая сортировка (Quick Sort)
 * Принцип работы: Выбирается "опорный" элемент, после чего массив делится на две части: в одной — все элементы меньше опорного, в другой — больше. Этот процесс рекурсивно повторяется для каждой из частей.
 * Временная сложность: В среднем O(n \log n), в худшем случае — O(n^2).
7. Пирамидальная сортировка (Heap Sort)
 * Принцип работы: Алгоритм сначала выстраивает из исходного массива структуру данных "куча" (max-heap), где наибольший элемент находится в корне. Затем он последовательно извлекает этот максимальный элемент и перемещает его в конец отсортированной части массива.
 * Временная сложность: O(n \log n).
