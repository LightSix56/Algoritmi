## Определение алгоритма

**Жадный алгоритм для составления расписания (Longest Processing Time First / LPT)** — это алгоритм, который на каждом шаге распределяет очередную работу на машину с наименьшей текущей загрузкой, стремясь сбалансировать общую нагрузку.


## Анализ работы алгоритма

Алгоритм начинает с инициализации массива `machines`, представляющего текущую загрузку каждой из `num_machines` машин, и массива `assignment`, в котором будет храниться индекс машины, которой назначена каждая работа.

- `machines = [0] * num_machines`
- `assignment = [0] * len(jobs)`

Далее, для каждой работы из списка `jobs` (цикл `for i in range(len(jobs)):`):

1. Находится минимальная текущая загрузка среди всех машин:
   - `min_load = min(machines)`
2. Определяется индекс первой машины, имеющей эту минимальную загрузку:
   - `machine_index = machines.index(min_load)`
3. Длительность текущей работы `jobs[i]` добавляется к загрузке выбранной машины:
   - `machines[machine_index] += jobs[i]`
4. Индекс выбранной машины сохраняется в массиве `assignment` для текущей работы:
   - `assignment[i] = machine_index`

После завершения цикла, функция возвращает массив `assignment`, показывающий, на какую машину была распределена каждая работа, и массив `machines`, отражающий итоговую загрузку каждой машины.


## Временная сложность

O(n * m), где `n` — количество работ, `m` — количество машин.


## Обоснование временной сложности

- Цикл `for i in range(len(jobs))` выполняется `n` раз.
- Внутри цикла:
  - Функция `min(machines)` проходит по всем `m` элементам массива `machines`, чтобы найти минимальное значение. Это операция O(m).
  - Функция `machines.index(min_load)` также может потребовать до `m` шагов для поиска индекса минимального элемента. Это также O(m).
  - Остальные операции (`machines[machine_index] += jobs[i]`, `assignment[i] = machine_index`) выполняются за O(1).

Таким образом, общая сложность составляет `n * (O(m) + O(m))`, что упрощается до **O(n * m)**.
