## Жадный алгоритм для составления расписания(вариант 2)

## Определение алгоритма

**Жадный алгоритм для составления расписания** — это алгоритм, который на каждом шаге распределяет очередную работу на машину с наименьшей текущей загрузкой, стремясь сбалансировать общую нагрузку.


## Анализ работы алгоритма

Алгоритм начинает с инициализации массива `machines`, представляющего текущую загрузку каждой из `num_machines` машин, и массива `assignment`, в котором будет храниться индекс машины, которой назначена каждая работа.

- `machines = [0] * num_machines`
- `assignment = [0] * len(jobs)`

Далее, для каждой работы из списка `jobs` (цикл `for i in range(len(jobs)):`):

1. Находится минимальная текущая загрузка среди всех машин:
   - `min_load = min(machines)`
2. Определяется индекс первой машины, имеющей эту минимальную загрузку:
   - `machine_index = machines.index(min_load)`
3. Длительность текущей работы `jobs[i]` добавляется к загрузке выбранной машины:
   - `machines[machine_index] += jobs[i]`
4. Индекс выбранной машины сохраняется в массиве `assignment` для текущей работы:
   - `assignment[i] = machine_index`

После завершения цикла, функция возвращает массив `assignment`, показывающий, на какую машину была распределена каждая работа, и массив `machines`, отражающий итоговую загрузку каждой машины.


## Временная сложность

O(n * m), где `n` — количество работ, `m` — количество машин.


## Обоснование временной сложности

- Цикл `for i in range(len(jobs))` выполняется `n` раз.
- Внутри цикла:
  - Функция `min(machines)` проходит по всем `m` элементам массива `machines`, чтобы найти минимальное значение. Это операция O(m).
  - Функция `machines.index(min_load)` также может потребовать до `m` шагов для поиска индекса минимального элемента. Это также O(m).
  - Остальные операции (`machines[machine_index] += jobs[i]`, `assignment[i] = machine_index`) выполняются за O(1).

Таким образом, общая сложность составляет `n * (O(m) + O(m))`, что упрощается до **O(n * m)**.

---

## Контрольный вопрос(вариант 2)
**Коэффициент аппроксимации**

**Коэффициент аппроксимации**

Для задачи минимизации коэффициент аппроксимации α (α ≥ 1) определяется как отношение стоимости решения, найденного приближённым алгоритмом, к стоимости оптимального решения:

**α = A(I) / OPT(I)**

где:
- `A(I)` — стоимость решения, выданного алгоритмом на входе `I`,
- `OPT(I)` — стоимость оптимального решения для входа `I`.

**Что он характеризует:**
Коэффициент α показывает, **насколько хуже** (в худшем случае) решение, полученное приближённым алгоритмом, по сравнению с оптимальным. Чем ближе α к 1, тем лучше алгоритм. Например, α=2 означает, что алгоритм всегда даёт решение, не хуже чем в 2 раза от оптимального.
