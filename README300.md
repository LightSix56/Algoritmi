Бинарная куча
Определение: Это структура данных, которая представляет собой одно полное бинарное дерево.
Особенности формирования:
  Добавление: Новый элемент добавляется в конец и «поднимается» вверх, пока не встанет на нужное место.
  Извлечение: Самый маленький (или самый большой) элемент удаляется, а его место занимает последний элемент, который затем «опускается» вниз до нужной позиции.

Биномиальная куча
Определение: Это структура данных, которая состоит из набора биномиальных деревьев.
Особенности формирования:
  Вставка: Создается новая куча с одним элементом, которая затем объединяется с основной кучей.
  Объединение: Списки корней двух куч сливаются в один.

Куча Фибоначчи
Определение: Эта структура данных представляет собой коллекцию деревьев.
Особенности формирования:
  Вставка: Элемент просто вставляется в кучу.
  Слияние: Одна куча объединяется с другой, что является одной из ключевых операций.
  Удаление минимума: Узел с наименьшим ключом удаляется.

Хеш-таблицы
Определение: Это структуры данных, которые хранят информацию в виде пар «ключ-значение».
Особенности формирования: В отличие от куч, хеш-таблицы не формируются как деревья. Они реализуются на основе массивов и, например, односвязных списков, где каждый элемент хранится по адресу, который вычисляется на основе его ключа.




Бинарная куча (на основе массива)
Python
В Python бинарная куча может быть реализована как собственный класс или с использованием модуля heapq. heapq поддерживает только минимальную кучу, для создания максимальной кучи можно инвертировать значения.
Пример использования:
  Создание списка: [8, 3, 5, 1, 6, 2, 4, 7].
  Превращение списка в кучу: heapify().
  Добавление элемента: heappush().
  Извлечение минимального элемента: heappop().

C++
В C++ бинарная куча реализуется как полное бинарное дерево. Она может быть представлена с помощью std::vector.
Пример операций:
  Добавление элемента: новый элемент добавляется в конец и "поднимается" вверх, пока свойство кучи не будет соблюдено.
  Извлечение минимального элемента: корень кучи (минимальный элемент) извлекается, а последний элемент перемещается на его место, после чего "опускается" вниз.
  Удаление узла: узел заменяется последним элементом, затем восстанавливается свойство кучи.

Java
В Java двоичная куча (Binary Heap) может быть реализована на основе массива.
Пример операций:
  Вставка: новый элемент добавляется в конец массива, затем свойство кучи восстанавливается путем "подъема" элемента.
  Извлечение минимального элемента: корень кучи заменяется последним элементом, и свойство кучи восстанавливается путём "heapifying down" из корневого узла.

Биномиальная куча
Python
Биномиальная куча в Python может быть реализована с помощью собственного класса, так как нет встроенной реализации.
Особенности:
  Представляет собой набор биномиальных деревьев.
  Каждое дерево имеет разный размер.
  Это "сливаемая куча", что означает, что она предоставляет дополнительную операцию слияния двух куч.

C++
В C++ биномиальная куча реализуется как коллекция биномиальных деревьев.
Пример операций:
  Вставка: создается куча с одним узлом, а затем объединяется с текущей.
  Объединение: объединяются списки корней двух куч.
  Извлечение минимума: извлекается узел с наименьшим ключом.

Java
Биномиальная куча в Java может быть реализована без внешних библиотек на основе стандартной Java.
Пример операций:
  Вставка: элемент вставляется в кучу.
  Удаление минимума: узел с минимальным ключом удаляется.
  Слияние: текущая куча объединяется с другой кучей.


Куча Фибоначчи
Python
В Python нет встроенной структуры данных "куча Фибоначчи". Есть примеры для работы с числами ряда Фибоначчи, которые представляют собой последовательность, где каждое число является суммой двух предыдущих.
Пример:
  Рекурсивная функция для вычисления n-го числа ряда Фибоначчи: fibonacci(n).
  Функция вызывает себя для n-1 и n-2.

C++
В C++ нет встроенной структуры данных "куча Фибоначчи", но могут быть созданы реализации для хранения элементов, связанных с последовательностью Фибоначчи.
Пример:
  Реализация класса FibonacciHeap с такими операциями, как insert(key), unite(other_heap), getMin, extractMin, decreaseKey(element, new_key) и deleteElement(element).

Java
В Java можно реализовать "кучу Фибоначчи" с помощью рекурсивного алгоритма.
Пример:
  Метод fibonacci(long n).
  Метод вызывает себя дважды для вычисления чисел Фибоначчи на позициях n-1 и n-2, а затем складывает их.
  Базовый случай: если n равно 0 или 1, возвращается n.

Хеш-таблицы
Python
В Python хеш-таблицы реализованы через встроенный тип данных словаря (dict). Можно также создать собственную реализацию.
Пример использования словаря:
  Добавление пары "ключ-значение": hash_table.set('Alice', 'January').
  Получение значения по ключу: hash_table.get('Alice').
  Удаление записи: hash_table.remove('Bob').
  Важно: в качестве ключей должны использоваться только неизменяемые типы данных (строки, числа, кортежи).

C++
В C++ хеш-таблицы доступны через стандартную библиотеку шаблонов (STL), например, std::unordered_map. Также можно написать реализацию вручную.
Пример использования std::unordered_map:
  Создание: unordered_map<string, int> umap;.
  Вставка: umap["Apple"] = 10;.
  Коллизии обрабатываются с помощью цепочечного хеширования.

Java
В Java для хеш-таблиц используются классы Hashtable и HashMap. HashMap реализован на основе массива односвязных списков.
Пример использования HashMap:
  Создание: HashMap<String, Integer> hashMap = new HashMap<>();.
  Добавление: hashMap.put("John", 25);.
  Получение: hashMap.get("John");.
  Удаление: hashMap.remove("Jim");.
